<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.yguilai.com</id>
    <title>燕归来博客</title>
    <updated>2020-06-02T11:59:54.293Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.yguilai.com"/>
    <link rel="self" href="https://blog.yguilai.com/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://blog.yguilai.com/images/avatar.png</logo>
    <icon>https://blog.yguilai.com/favicon.ico</icon>
    <rights>All rights reserved 2020, 燕归来博客</rights>
    <entry>
        <title type="html"><![CDATA[Typescript泛型约束]]></title>
        <id>https://blog.yguilai.com/post/ZUto8nM6t/</id>
        <link href="https://blog.yguilai.com/post/ZUto8nM6t/">
        </link>
        <updated>2020-06-02T11:46:41.000Z</updated>
        <summary type="html"><![CDATA[<p>泛型约束就是使用一个类型和extends对泛型进行约束</p>
]]></summary>
        <content type="html"><![CDATA[<p>泛型约束就是使用一个类型和extends对泛型进行约束</p>
<!-- more -->
<h3 id="泛型约束">泛型约束</h3>
<p>例子:</p>
<pre><code class="language-ts">interface WithLength {
    length: number
}
const getLength = &lt;T extends WithLength&gt;(param: T): number =&gt; {
    return param.length
}
getLength(&quot;abcdefg&quot;)    // 7
getLength([1, 2, 3])        // 3
getLength({ length: 5 }) // 5
getLength(123)             // error 类型“123”的参数不能赋给类型“WithLength”的参数
</code></pre>
<p>从上述例子可以看到, 泛型变量<code>T</code>受到接口<code>WithLenght</code>的约束, 不管它是什么类型, 但必须有一个length属性.</p>
<h3 id="泛型约束中使用类型参数">泛型约束中使用类型参数</h3>
<p>例子:</p>
<pre><code class="language-ts">const getProp = (obj, propName) =&gt; {
    return obj[propName]
}
const obj = { a: 'aaa', b: 'bbb' }
getProp(obj, 'c')   // undefined
</code></pre>
<p>从上面这个例子可以看出, 当获取这个对象的<code>'c'</code>属性时, 就会得到<code>undefined</code>. 这里我们就需要用到索引类型<code>keyof</code>结合泛型来实现对这个问题的检查</p>
<pre><code class="language-ts">const getProp = &lt;T, K extends keyof T&gt;(obj: T, propName: K) =&gt; {
    return obj[propName]
}
const obj = { a: 'aaa', b: 'bbb' }
getProp(obj, 'c')   // 类型“&quot;c&quot;”的参数不能赋给类型“&quot;a&quot; | &quot;b&quot;”的参数
</code></pre>
<blockquote>
<p><code>keyof</code>可以理解为一个由泛型变量<code>T</code>的属性名构成的联合类型, 因此<code>K</code>就被约束为了只能时<code>'a'</code>或<code>'b'</code>, 所传入字符串<code>'c'</code>时, ts就会检测出错误</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typescript中的类型断言]]></title>
        <id>https://blog.yguilai.com/post/Zwy9o_K7j/</id>
        <link href="https://blog.yguilai.com/post/Zwy9o_K7j/">
        </link>
        <updated>2020-06-01T13:48:50.000Z</updated>
        <summary type="html"><![CDATA[<p>两种写法, 一种是<code>&lt;type&gt;value</code>, 一种是<code>value as type</code></p>
]]></summary>
        <content type="html"><![CDATA[<p>两种写法, 一种是<code>&lt;type&gt;value</code>, 一种是<code>value as type</code></p>
<!-- more -->
<p>例子:</p>
<pre><code class="language-typescript">const getStrLength = (target: string | number): number =&gt; {
    if ((&lt;string&gt;targer).length) {  // 这种写法在jsx中不支持, 同时也是tslint不建议的写法
        return (target as string).length    // 建议写法
    } else {
        return target.toString().length
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typescript中补充的六个类型]]></title>
        <id>https://blog.yguilai.com/post/zpYjIzrB_/</id>
        <link href="https://blog.yguilai.com/post/zpYjIzrB_/">
        </link>
        <updated>2020-06-01T13:26:04.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h4 id="元组">元组</h4>
<ul>
<li>元组可以看作是数组的拓展, 它表示已知的元素数量和类型的数组</li>
<li>通过<code>let tuple: [string, number, boolean]</code>的方式定义</li>
<li>各个位置上的元素类型都要对应, 元素个数也要一致</li>
</ul>
<h4 id="枚举">枚举</h4>
<ul>
<li>ts在es原有类型鸡出上加入枚举类型</li>
</ul>
<h4 id="any">Any</h4>
<ul>
<li>程序有时是多变的, 有时我们在编写代码时并不能清楚的知道一个值到底时什么类型, 这个时候就需要用到any类型, eg: <code>let dom: any = document.getElementById('myId')</code></li>
<li>可以在定义数组类型时使用any来指定数组中的元素类型为任意类型</li>
<li>不应该滥用any类型, 如果任何值都指定为any类型, 那么typescript就变成了&quot;anyscript&quot;😂</li>
</ul>
<h4 id="void">void</h4>
<ul>
<li>void和any相反, any表示任意类型, void则是表示没有任意类型</li>
<li>定义函数, 没有返回值时常用到</li>
<li>void类型的变量只能赋值为<code>undefined</code>和<code>null</code></li>
</ul>
<h4 id="nerver">nerver</h4>
<ul>
<li>never类型指那些永不存在的类型</li>
<li>除它自身外, 任何类型都不能赋值给never类型</li>
</ul>
<h4 id="unknown">unknown</h4>
<ul>
<li>unknown和any很像, 但是unknown相对与any是安全的</li>
</ul>
<h4 id="拓展类型">拓展类型</h4>
<ul>
<li>交叉类型
<ul>
<li>使用<code>&amp;</code>符号定义, 被<code>&amp;</code>符号链接的多个类型构成一个交叉类型</li>
</ul>
</li>
<li>联合类型
<ul>
<li>联合类型是要求是要符合联合类型中任意一种类型即可, 使用<code>|</code>符号定义</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[yarn create react-app 报错文件名、目录名或卷标语法不正确]]></title>
        <id>https://blog.yguilai.com/post/x1hPVO9h_/</id>
        <link href="https://blog.yguilai.com/post/x1hPVO9h_/">
        </link>
        <updated>2020-05-27T07:29:09.000Z</updated>
        <summary type="html"><![CDATA[<p>最近学习react, 看官方文档利用yarn新建项目运行<code>yarn create react-app my-app</code>直接报错</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近学习react, 看官方文档利用yarn新建项目运行<code>yarn create react-app my-app</code>直接报错</p>
<!-- more -->
<p>看网上解决办法很多都是修改<code>create-react-app.cmd</code>, 然后添加环境变量, 感觉很不<code>优雅</code></p>
<p>查了很多资料后, 发现主要原因是我用npm全局安装的yarn, 导致yarn的bin目录与安装目录在不同分区🙄</p>
<p>查看yarn的bin目录</p>
<pre><code class="language-bash">yarn global bin
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://blog.yguilai.com/post-images/1590565038111.png" alt="" loading="lazy"></figure>
<p>查看yarn的安装目录</p>
<pre><code class="language-bash">yarn global dir
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://blog.yguilai.com/post-images/1590565172092.png" alt="" loading="lazy"></figure>
<blockquote>
<p>这里是我已经修改了的, 原来是在C盘</p>
</blockquote>
<p>如果发现bin目录与安装目录不在同一个分区, 就将yarn的安装位置修改到同一分区</p>
<pre><code class="language-bash">yarn config set global-folder &quot;D:\Develop\yarn\global&quot;
yarn config set cache-folder &quot;D:\Develop\yarn\cache&quot;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://blog.yguilai.com/post-images/1590565331006.png" alt="" loading="lazy"></figure>
<p>再运行<code>yarn create react-app my-app</code>可以发现已经搞定了👌</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Win10解决无法调节屏幕亮度问题]]></title>
        <id>https://blog.yguilai.com/post/TKVP2Etmw/</id>
        <link href="https://blog.yguilai.com/post/TKVP2Etmw/">
        </link>
        <updated>2020-05-20T12:00:17.000Z</updated>
        <summary type="html"><![CDATA[<p>网上找了很多方法, 如: 重装集显驱动、修改注册表, 都没用</p>
]]></summary>
        <content type="html"><![CDATA[<p>网上找了很多方法, 如: 重装集显驱动、修改注册表, 都没用</p>
<!-- more -->
<p>如果安装了TeamViewer, 向日葵之类的远程控制软件, 会自动安装监视器驱动</p>
<p>解决办法:<br>
Win+R打开运行窗口, 输入<code>devmgmt.msc</code>, 回车打开设备管理器面板, 找到监视器</p>
<p>可以发现监视器驱动显示为<code>PnP-Monitor(Standard)</code> (厂商为TeamViewer) 或者<code>Generic Monitor (orayOPMS)</code>(厂商为向日葵)<br>
<img src="https://blog.yguilai.com/post-images/1589976540518.jpg" alt="" loading="lazy"></p>
<p>右键选中对应驱动, 打开<code>属性</code> &gt; <code>驱动程序</code> &gt; <code>更新驱动程序</code> &gt; <code>浏览计算机以查找驱动程序软件</code> &gt; <code>从计算机的设备驱动程序列表中选取</code> &gt; 选中<code>通用即插即用监视器</code>, 点击下一步安装即可, 最好重启一下电脑</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go日志库Zap与lumberjack配置]]></title>
        <id>https://blog.yguilai.com/post/L_yuiYNgS/</id>
        <link href="https://blog.yguilai.com/post/L_yuiYNgS/">
        </link>
        <updated>2020-05-19T14:20:02.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-go">package core

import (
	&quot;go-gin-api-example/core/global&quot;
	&quot;go.uber.org/zap&quot;
	&quot;go.uber.org/zap/zapcore&quot;
	&quot;gopkg.in/natefinch/lumberjack.v2&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func initZapLogger() {
	var logger *zap.Logger
	core := zapcore.NewCore(newZapEncoder(), newWriteSyncer(), newZapLevel())

	// set initialize fields
	field := zap.Fields(zap.String(&quot;ApplicationName&quot;, global.CONFIG.App.Name))

	// judge current environment is pro?
	if global.CONFIG.App.Env != &quot;pro&quot; {
		// enable dev mode
		caller := zap.AddCaller()
		development := zap.Development()
		logger = zap.New(core, caller, development, field)
	} else {
		logger = zap.New(core, field)
	}

	// save as a global variable
	global.LOG = logger
}

func newWriteSyncer() zapcore.WriteSyncer {
	if !global.CONFIG.Log.EnableLogFile {
		return zapcore.NewMultiWriteSyncer(zapcore.AddSync(os.Stdout))
	} else {
		logConfig := global.CONFIG.Log
		hook := lumberjack.Logger{
			Filename:   logConfig.File.Path + string(os.PathSeparator) + global.CONFIG.App.Name + &quot;.log&quot;,
			MaxSize:    logConfig.File.MaxSize,
			MaxBackups: logConfig.File.MaxBackups,
			MaxAge:     logConfig.File.MaxAge,
			Compress:   logConfig.File.Compress,
		}
		return zapcore.NewMultiWriteSyncer(zapcore.AddSync(os.Stdout), zapcore.AddSync(&amp;hook))
	}
}

func newZapEncoder() zapcore.Encoder {
	encoderCfg := zapcore.EncoderConfig{
		TimeKey:        &quot;time&quot;,
		LevelKey:       &quot;level&quot;,
		NameKey:        &quot;logger&quot;,
		CallerKey:      &quot;lineNum&quot;,
		MessageKey:     &quot;msg&quot;,
		StacktraceKey:  &quot;stacktrace&quot;,
		LineEnding:     zapcore.DefaultLineEnding,
		EncodeLevel:    zapcore.CapitalLevelEncoder,    // 大写编码器
		EncodeTime:     zapcore.ISO8601TimeEncoder,     // ISO8601 UTC 时间格式
		EncodeDuration: zapcore.SecondsDurationEncoder,
		EncodeCaller:   zapcore.ShortCallerEncoder,     // 短路径编码器
		EncodeName:     zapcore.FullNameEncoder,
	}

	if global.CONFIG.Log.Encoder == &quot;json&quot; {
		return zapcore.NewJSONEncoder(encoderCfg)
	} else {
		return zapcore.NewConsoleEncoder(encoderCfg)
	}
}

func newZapLevel() zap.AtomicLevel {
	levelMap := map[string]zapcore.Level{
		&quot;DEBUG&quot;:  zap.DebugLevel,
		&quot;INFO&quot;:   zap.InfoLevel,
		&quot;WARN&quot;:   zap.WarnLevel,
		&quot;ERROR&quot;:  zap.ErrorLevel,
		&quot;DPANIC&quot;: zap.DPanicLevel,
		&quot;PANIC&quot;:  zap.PanicLevel,
		&quot;FATAL&quot;:  zap.FatalLevel,
	}

	level := zap.NewAtomicLevel()
	if l, ok := levelMap[strings.ToUpper(global.CONFIG.Log.Level)]; ok {
		level.SetLevel(l)
	} else {
		level.SetLevel(zap.InfoLevel)
	}

	return level
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ElementUI自定义上传 -以上传图标到七牛云为例]]></title>
        <id>https://blog.yguilai.com/post/elementui-zi-ding-yi-shang-chuan-yi-shang-chuan-tu-biao-dao-qi-niu-yun-wei-li/</id>
        <link href="https://blog.yguilai.com/post/elementui-zi-ding-yi-shang-chuan-yi-shang-chuan-tu-biao-dao-qi-niu-yun-wei-li/">
        </link>
        <updated>2020-05-19T07:30:51.000Z</updated>
        <summary type="html"><![CDATA[<p>解决ElementUI上传组件无法获取内部文件列表的缺陷</p>
]]></summary>
        <content type="html"><![CDATA[<p>解决ElementUI上传组件无法获取内部文件列表的缺陷</p>
<!-- more -->
<pre><code class="language-html">&lt;template&gt;
    &lt;div&gt;
        &lt;el-upload
            action=&quot;#&quot;
            class=&quot;icon-uploader&quot;
            :auto-upload=&quot;false&quot;
            :on-change=&quot;onIcoUploadChange&quot;
            :show-file-list=&quot;false&quot;
            accept=&quot;image/*&quot;
          &gt;
            &lt;img v-if=&quot;imageUrl !== ''&quot; :src=&quot;imageUrl&quot; class=&quot;ico&quot; /&gt;
            &lt;i v-else class=&quot;el-icon-plus&quot; /&gt;
            &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;
              只能上传图片文件，且不超过200kb
            &lt;/div&gt;
          &lt;/el-upload&gt;
          &lt;el-button @click=&quot;upload()&quot;&gt;上传&lt;/el-button&gt;
    &lt;/div&gt;
&lt;/ template&gt;

&lt;script&gt;
export default {
    data() {
        return {
            icoFile: null,
            imageUrl: '',
            qiniuToken: ''
        }
    },
    methods: {
        // 获取上传的文件对象
        onIcoUploadChange(file, fileList) {
            this.icoFile = file
            // 创建一个本地blob链接用于图片预览
            this.imageUrl = URL.createObjectURL(file.raw)
        },
        // 上传文件到七牛
        async upload() {
            if (this.icoFile === null) {
                this.$message.error('请先上传文件')
                return
            }

            // 判断token是否为空
            if (this.qiniuToken === '') {
                try {
                const { data } = await getQiniuToken()
                this.qiniuToken = data
                } catch (err) {
                this.$message.error(err.message)
                return
                }
            }

            let fileKey = ''

            try {
                const formData = new FormData()
                formData.append('file', this.icoFile)
                formData.append('token', this.qiniuToken)
                const { key } = await uploadImg2Qiniu(formData)
                fileKey = key
                // 发送请求 将key存到数据库
                // ...
            } catch (err) {
                this.$message.error(err.message)
            }
        }
    }
}
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scope&gt;
$icoSize: 64px;

.icon-uploader .el-upload {
  width: $icoSize;
  height: $icoSize;
  position: relative;
  overflow: hidden;
  border: 1px dashed #d9d9d9;
  border-radius: 6px;
  cursor: pointer;
  position: relative;
  overflow: hidden;

  &amp;:hover {
    border-color: #409eff;
  }
}

.icon-uploader .ico {
  width: $icoSize;
  height: $icoSize;
}

.icon-uploader .el-upload .el-icon-plus {
  width: $icoSize;
  height: $icoSize;
  font-size: 20px;
  color: #8c939d;
  line-height: $icoSize;
  text-align: center;
}
&lt;/style&gt;
</code></pre>
<p>获取token及上传图片</p>
<pre><code class="language-js">import request from '@/utils/request'

// 获取后端生成的token
export function getQiniuToken() {
  return request({
    url: '/qntoken',
    method: 'GET'
  })
}

export function uploadImg2Qiniu(formdata) {
  return request({
    // 该api从七牛获取, 不同地域的存储桶对应api不同
    url: process.env.VUE_APP_QINIU_UPLOAD_API, 
    method: 'POST',
    headers: {
      'Content-Type': 'multipart/form-data'
    },
    withCredentials: false, // 禁止跨域携带cookie，带cookie在七牛上有可能出现跨域问题
    timeout: 30000,
    data: formdata
  })
}
</code></pre>
]]></content>
    </entry>
</feed>